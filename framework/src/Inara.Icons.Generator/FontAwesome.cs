using System.Text;

namespace Inara.Icons.Generator;

public class FontAwesomeFree : FontAwesome
{
    public override String License => """
        /*********************************************************************************
        * Fonticons, Inc. (https://fontawesome.com)
        * 
        * --------------------------------------------------------------------------------
        * 
        * Font Awesome Free License
        * 
        * Font Awesome Free is free, open source, and GPL friendly. You can use it for
        * commercial projects, open source projects, or really almost whatever you want.
        * Full Font Awesome Free license: https://fontawesome.com/license/free.
        * 
        * --------------------------------------------------------------------------------
        * 
        * # Icons: CC BY 4.0 License (https://creativecommons.org/licenses/by/4.0/)
        * 
        * The Font Awesome Free download is licensed under a Creative Commons
        * Attribution 4.0 International License and applies to all icons packaged
        * as SVG and JS file types.
        * 
        *********************************************************************************/
        """;

    public override String Namespace => "Inara.Icons.FontAwesome.Free";
}

public class FontAwesomePro : FontAwesome
{
    public override String License => """
        /*********************************************************************************
        * Font Awesome Pro License
        * ------------------------
        * 
        * Font Awesome Pro is commercial software that requires a paid license. Full
        * Font Awesome Pro license: https://fontawesome.com/license.
        * 
        * # Commercial License
        * The Font Awesome Pro commercial license allows you to pay for FA Pro once, own
        * it, and use it just about everywhere you'd like.
        * 
        * # Attribution
        * Attribution is not required by the Font Awesome Pro commercial license.
        * 
        * # Brand Icons
        * All brand icons are trademarks of their respective owners. The use of these
        * trademarks does not indicate endorsement of the trademark holder by Font
        * Awesome, nor vice versa. **Please do not use brand logos for any purpose except
        * to represent the company, product, or service to which they refer.**        
        * 
        *********************************************************************************/
        """;

    public override String Namespace => "Inara.Icons.FontAwesome.Pro";
}

public abstract class FontAwesome
{
    public abstract String License { get; }
    public abstract String Namespace { get; }

    public async Task Generate(String svgPath, String outputPath)
    {
        if (!Directory.Exists(svgPath))
        {
            throw new DirectoryNotFoundException(svgPath);
        }

        if (!Directory.Exists(outputPath))
        {
            Directory.CreateDirectory(outputPath);
        }

        var files = Directory.EnumerateFiles(svgPath, "*.svg", SearchOption.AllDirectories);

        foreach (var kvp in ClassifyIcons(files))
        {
            await RenderFamily(outputPath, kvp.Key, kvp.Value).ConfigureAwait(false);
        }
    }

    private async Task RenderFamily(String classPath, String key, List<IconInfo> icons)
    {
        var chunks = key.Replace(".cs", String.Empty).Split('_');

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine(License);
        sb.AppendLine($"namespace {Namespace};");
        sb.AppendLine();

        var level = 0;
        var indent = Indent(level);
        foreach (var chunk in chunks)
        {
            indent = Indent(level++);
            sb.AppendLine($"{indent}public partial class {chunk}");
            sb.AppendLine($"{indent}{{");
        }

        indent = Indent(level);
        foreach (var icon in icons.OrderBy(i => i.Name))
        {
            var svg = await GetSvg(icon);
            sb.AppendLine($"{indent}public const String {icon.Name.MakeSafe()} = \"{svg}\";");
        }

        foreach (var chunk in chunks)
        {
            indent = Indent(--level);
            sb.AppendLine($"{indent}}}");
        }

        await File.WriteAllTextAsync(Path.Combine(classPath, key), sb.ToString(), Encoding.UTF8).ConfigureAwait(false);
    }

    private static async Task<String> GetSvg(IconInfo icon)
        => (await File.ReadAllTextAsync(icon.Path)).SVG();

    private static String Indent(Int32 indent)
        => indent > 0
            ? new String(' ', indent * 4)
            : String.Empty;

    private static Dictionary<String, List<IconInfo>> ClassifyIcons(IEnumerable<String> files)
    {
        var icons = new Dictionary<String, List<IconInfo>>();
        foreach (var file in files)
        {
            var info = new FileInfo(file);
            var icon = new IconInfo(info.Name, GetFamily(info.Directory!), GetStyle(info.Directory!), file);

            var key = GetKey(icon);
            if (icons.TryGetValue(key, out var value))
            {
                value.Add(icon);
            }
            else
            {
                icons.Add(key, [icon]);
            }
        }

        return icons;
    }

    private static Family GetFamily(DirectoryInfo directory) => directory.Name switch
    {
        "brands" => Family.Brands,
        "duotone" => Family.Duotone,
        "sharp-duotone-solid" => Family.SharpDuotone,
        "sharp-light" => Family.Sharp,
        "sharp-regular" => Family.Sharp,
        "sharp-solid" => Family.Sharp,
        "sharp-thin" => Family.Sharp,
        _ => Family.Classic
    };

    public static Style GetStyle(DirectoryInfo directory) => directory.Name switch
    {
        var x when x.Contains("light") => Style.Light,
        var x when x.Contains("regular") => Style.Regular,
        var x when x.Contains("solid") => Style.Solid,
        var x when x.Contains("thin") => Style.Thin,
        _ => Style.Solid
    };

    public static String GetKey(IconInfo icon)
    {
        switch (icon.Family)
        {
            case Family.Brands:
                return "FA_Brands.cs";
            case Family.Classic:
                switch (icon.Style)
                {
                    case Style.Light:
                        return "FA_Classic_Light.cs";
                    case Style.Regular:
                        return "FA_Classic_Regular.cs";
                    case Style.Solid:
                        return "FA_Classic_Solid.cs";
                    case Style.Thin:
                        return "FA_Classic_Thin.cs";
                }

                break;
            case Family.Duotone:
                return "FA_Duotone.cs";
            case Family.SharpDuotone:
                return "FA_SharpDuotone.cs";
            case Family.Sharp:
                switch (icon.Style)
                {
                    case Style.Light:
                        return "FA_Sharp_Light.cs";
                    case Style.Regular:
                        return "FA_Sharp_Regular.cs";
                    case Style.Solid:
                        return "FA_Sharp_Solid.cs";
                    case Style.Thin:
                        return "FA_Sharp_Thin.cs";
                }

                break;
        }

        throw new InvalidOperationException($"Unknown Family or Style: {icon.Family}");
    }

    public record IconInfo(String Name, Family Family, Style Style, String Path);

    public enum Family
    {
        Brands,
        Classic,
        Duotone,
        SharpDuotone,
        Sharp
    }

    public enum Style
    {
        Unspecified,
        Light,
        Regular,
        Solid,
        Thin
    }
}